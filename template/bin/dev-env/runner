#!/usr/bin/env bash
set -eu

PROJECT_NAME={{PROJECT_NAME}}
DEV_CONTAINER=$PROJECT_NAME-dev-env

if [ -z $PROJECT_NAME ]; then
    red='\033[0;31m'
    no_colour='\033[0m'
    printf "${red}Error: ${no_colour}\$PROJECT_NAME in ./bin/dev-env/runner is not set.\n"
    exit 1
fi

get_project_dir() {
    local home_dir="`dirname $BASH_SOURCE`/../../"
    echo `readlink -m $home_dir`
}

docker_compose() {
    local project_dir=`get_project_dir`
    local docker_compose_file="`dirname $BASH_SOURCE`/docker-compose.yml"

    # Note: declaring project name via -p is required to be able to exec into the containers
    PROJECT_DIR=$project_dir docker-compose \
        -f $docker_compose_file \
        -p $PROJECT_NAME $@
}

run_in_container() {
    set -u
    command=$@
    running_container=`docker ps --format '{{.Names}}' | grep -s "^$DEV_CONTAINER$" | head -n 1`

    if [[ -n $running_container ]]; then
        echo Running in existing container
        docker_compose exec $DEV_CONTAINER bash -l -c "$command"
    else
        echo Running in new container
        docker_compose run --rm --service-ports $DEV_CONTAINER -c "$command"
    fi
}

run() {
    set -u
    command=$@

    if [[ -f /.dockerenv ]]; then # check if we're in the container
        bash -c "$command"
    else
        run_in_container $command
    fi
}

inline_function() {
    set -u
    function=$1
    declare -f $function | sed '1,2d;$d' | tr -d '\n'
}

run_function() {
    set -u
    function=$1
    run "`inline_function $function`"
}